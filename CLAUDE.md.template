# AI Agent Prompt System - Architecture and Usage Guide

**Project**: {{PROJECT_NAME}}
**Version**: 1.0.0
**Last Updated**: {{LAST_UPDATED}}
**System Status**: Production-Ready with Memory System

---

## ğŸš« ABSOLUTE PROHIBITION: No Git Operations

**THIS IS AN ABSOLUTE AND NON-NEGOTIABLE RULE. NEVER VIOLATE THIS.**

### Prohibited Actions

The AI Agent is **ABSOLUTELY FORBIDDEN** from:
- âŒ Performing ANY git operations (commit, push, pull, merge, rebase, etc.)
- âŒ Suggesting git operations to the user
- âŒ Considering git operations in task planning
- âŒ Mentioning git operations in recommendations
- âŒ Creating commit messages
- âŒ Staging files with `git add`
- âŒ Checking git status (except for informational purposes when explicitly requested)

### Rationale

**Version control is EXCLUSIVELY the user's responsibility.** The AI Agent's role is:
- âœ… Create and modify files
- âœ… Maintain the memory system
- âœ… Produce documentation and analysis
- âœ… Answer questions

**NOT**:
- âŒ Manage version control
- âŒ Decide what/when to commit
- âŒ Push changes to remote repositories

### What To Do Instead

When work is complete:
1. âœ… Inform user: "Work complete. Files have been created/updated."
2. âœ… List affected files
3. âœ… Update memory system (episodic notes, indexes)
4. âŒ **DO NOT** offer to commit or suggest git commands

**The user will handle all git operations themselves.**

---

## Welcome

Welcome to the {{PROJECT_NAME}} AI Agent Prompt System, a sophisticated architecture designed to assist you in {{PROJECT_DESCRIPTION}} **with minimal context usage** through an advanced memory system.

This system implements a **memory-driven, task-oriented workflow** that enables the AI Agent to:
- âœ… Retain knowledge across sessions via persistent file-based memory
- âœ… Minimize context waste by avoiding unnecessary file reads
- âœ… Optimize performance through task-specific indexing (up to 91% context reduction)
- âœ… Maintain consistency by using memory as the source of truth

---

## ğŸš¨ MANDATORY: Memory-First Operating Principle

**THIS IS THE FOUNDATION OF ALL WORK. NEVER SKIP THIS.**

### The Three-Phase Mandatory Workflow

Every action MUST follow this sequence:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ PHASE 1: CONSULT MEMORY (BEFORE work)     â”‚
â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚
â”‚ 1. Read tags.json and topics.json         â”‚
â”‚ 2. Query for relevant knowledge           â”‚
â”‚ 3. Read semantic notes (stable knowledge) â”‚
â”‚ 4. Read episodic notes (history)          â”‚
â”‚ 5. Check task-specific index              â”‚
â”‚ 6. Read procedural notes (workflows)      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
               â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ PHASE 2: WORK (WITH memory as foundation) â”‚
â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚
â”‚ âœ… Use memory knowledge as base           â”‚
â”‚ âœ… Only read NEW code if memory lacking   â”‚
â”‚ âœ… Create notes IMMEDIATELY on discovery  â”‚
â”‚ âŒ NEVER re-analyze what's in memory      â”‚
â”‚ âŒ NEVER ignore existing knowledge        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
               â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ PHASE 3: UPDATE MEMORY (AFTER actions)    â”‚
â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚
â”‚ 1. Create/update semantic notes           â”‚
â”‚ 2. Create/update episodic notes           â”‚
â”‚ 3. Update indexes IMMEDIATELY             â”‚
â”‚ 4. Add cross-references                   â”‚
â”‚ 5. Link notes to outputs                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Critical Questions (Ask BEFORE every action)

- â“ Have I read tags.json and topics.json?
- â“ Does memory already contain what I need?
- â“ Did I (in past session) already analyze this?
- â“ Are there semantic notes for these concepts?
- â“ Is there a task-specific index to optimize reading?

**If answer to ANY is "I don't know" â†’ You MUST read memory FIRST**

### Memory-First Checklist

**Session Start** (ALWAYS do these):
- [ ] Read `/{{BASE_DIR}}/memory/index/tags.json`
- [ ] Read `/{{BASE_DIR}}/memory/index/topics.json`
- [ ] Read last 1-2 episodic notes
- [ ] Query and read relevant semantic notes
- [ ] Check for task-specific index
- [ ] Read `/{{BASE_DIR}}/memory/procedural/memory-first-workflow.md` if unsure

**During Work** (Continuous):
- [ ] Using memory as foundation (not re-deriving)
- [ ] Creating semantic notes IMMEDIATELY on new discoveries
- [ ] Updating episodic notes with progress (not waiting till end)
- [ ] Adding cross-references when finding related concepts

**Before Finishing** (MANDATORY before marking task complete):
- [ ] Created episodic note documenting session
- [ ] Created/updated semantic notes for stable insights
- [ ] Updated tags.json and topics.json
- [ ] Added cross-references between related notes
- [ ] Linked episodic note to output files

**âŒ CRITICAL ANTI-PATTERNS (NEVER do these)**:
- âŒ Starting work without reading memory
- âŒ Re-analyzing code already in semantic notes
- âŒ Batching note creation till task end
- âŒ Creating notes without updating indexes
- âŒ Ignoring existing knowledge in memory

**ğŸ“– Detailed Workflow**: See `/{{BASE_DIR}}/memory/procedural/memory-first-workflow.md` for complete operating procedures, decision trees, and anti-pattern fixes.

---

## System Architecture Overview

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    USER INTERACTION                          â”‚
â”‚  "Please work on Task 3" OR "Analyze the Query API"         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚
                 â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  MEMORY SYSTEM (First)                       â”‚
â”‚  â€¢ Global Index (tags, topics)                              â”‚
â”‚  â€¢ Semantic Memory (stable knowledge)                       â”‚
â”‚  â€¢ Episodic Memory (task history)                           â”‚
â”‚  â€¢ Task-Specific Index (context optimization)               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚
                 â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚               PROMPT SYSTEM (On Demand)                      â”‚
â”‚  â€¢ Global Config (0.overview.md, 0.memory.md)               â”‚
â”‚  â€¢ Task Prompts (task-specific files)                       â”‚
â”‚  âš ï¸  ONLY read when user explicitly mentions a task         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚
                 â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   TASK EXECUTION                             â”‚
â”‚  â€¢ Use memory for knowledge                                 â”‚
â”‚  â€¢ Analyze codebase as needed                               â”‚
â”‚  â€¢ Produce outputs to /{{BASE_DIR}}/result/<N>/             â”‚
â”‚  â€¢ Update memory system                                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ¯ Critical Principle: Memory First, Prompts On-Demand

### âš ï¸ DO NOT Read Task Prompts Proactively

**IMPORTANT**: Task prompt files should **ONLY** be read when:
1. User explicitly mentions a task number: "Do Task 3", "Work on Task 2", etc.
2. User explicitly requests the task by name or description

**DO NOT** read task prompts:
- âŒ At session start
- âŒ "Just to see what's available"
- âŒ "To understand the project"
- âŒ Before user requests a specific task

**Why**: Task prompts can be large (1000+ lines). Reading them wastes context and violates the memory-first principle.

### âœ… What to Read Instead

**At Session Start**:
1. **This file** (`CLAUDE.md`) - You're already reading it
2. **Global configuration** (`/{{BASE_DIR}}/prompt/0.overview.md`) - Mandatory rules
3. **Memory policy** (`/{{BASE_DIR}}/prompt/0.memory.md`) - How to use memory system
4. **Memory indexes** (`/{{BASE_DIR}}/memory/index/tags.json`, `topics.json`) - What knowledge exists
5. **Recent episodic notes** (last 1-2 from `/{{BASE_DIR}}/memory/episodic/`) - What was done recently

**When User Asks a Question**:
1. **Query memory indexes** first to find relevant semantic notes
2. **Read semantic notes** for stable knowledge
3. **Read episodic notes** for task history
4. **Only if memory insufficient**: Read codebase or task outputs

**When User Requests a Task**:
1. **Read task prompt** (`/{{BASE_DIR}}/prompt/<task-file>.md`)
2. **Check for task-specific index** (`/{{BASE_DIR}}/memory/index/task-<N>-index.json`)
3. **Use index to read selectively** (if index exists)
4. **Execute task using memory + selective reading**

---

## Directory Structure and Reading Strategy

### `/{{BASE_DIR}}/prompt/` - Global Config and Task Definitions

```
/{{BASE_DIR}}/prompt/
â”œâ”€â”€ 0.overview.md              # READ: At session start (MANDATORY)
â”œâ”€â”€ 0.memory.md                # READ: At session start (MANDATORY)
â””â”€â”€ <task-files>.md            # READ: ONLY when user requests specific task
```

**Reading Priority**:
1. **Always read first**: `0.overview.md`, `0.memory.md`
2. **Read on demand**: Task-specific files only when task explicitly requested
3. **Never read**: "Just browsing" or "to understand the project"

### `/{{BASE_DIR}}/memory/` - Persistent Knowledge (Primary Source)

```
/{{BASE_DIR}}/memory/
â”œâ”€â”€ DESIGN.md                  # READ: For memory system architecture
â”œâ”€â”€ semantic/                  # READ: For stable knowledge
â”‚   â””â”€â”€ <concept>.md           # (sem-NNN)
â”œâ”€â”€ episodic/                  # READ: For task history
â”‚   â””â”€â”€ YYYYMMDD-t<N>-<slug>.md  # (ep-NNN)
â”œâ”€â”€ procedural/                # READ: For workflows
â”‚   â”œâ”€â”€ memory-system-operations.md
â”‚   â””â”€â”€ memory-first-workflow.md
â”œâ”€â”€ system/                    # READ: For universal tool knowledge
â”‚   â”œâ”€â”€ tools/
â”‚   â”‚   â”œâ”€â”€ mermaid-diagrams.md
â”‚   â”‚   â”œâ”€â”€ markdown-best-practices.md
â”‚   â”‚   â””â”€â”€ code-reference-format.md
â”‚   â””â”€â”€ index/
â””â”€â”€ index/                     # READ: At session start, before queries
    â”œâ”€â”€ tags.json              # Quick lookup
    â”œâ”€â”€ topics.json            # Organized by area
    â””â”€â”€ task-<N>-index.json    # Task-specific optimization
```

**Reading Strategy**:
1. **Start every session**: Read `tags.json` and `topics.json` to know what exists
2. **For questions**: Query index â†’ identify note IDs â†’ read specific semantic notes
3. **For task history**: Read relevant episodic notes (sorted by date, most recent first)
4. **For workflows**: Read procedural notes
5. **Optimize with task index**: If task-N-index.json exists, use it to read only needed sections

### `/{{BASE_DIR}}/result/` - Task Outputs (Secondary Source)

```
/{{BASE_DIR}}/result/
â”œâ”€â”€ 1/                         # Task 1 outputs
â”œâ”€â”€ 2/                         # Task 2 outputs
â””â”€â”€ 3/                         # Task 3 outputs
```

**Reading Strategy**:
1. **Avoid reading entire outputs**: Task outputs can be 1000+ lines each
2. **Prefer memory notes**: Semantic notes extract key concepts from outputs
3. **Use task-specific index**: If task-N-index.json exists, it specifies exact sections to read
4. **Read selectively**: If memory insufficient, read specific sections (not entire files)

### `/{{BASE_DIR}}/temp/` - Temporary Working Directory

```
/{{BASE_DIR}}/temp/            # Temporary artifacts (NOT in git)
â”œâ”€â”€ task-1/
â”œâ”€â”€ task-2/
â””â”€â”€ task-<N>/
    â”œâ”€â”€ brainstorm/
    â”œâ”€â”€ drafts/
    â”œâ”€â”€ analysis/
    â”œâ”€â”€ reference/
    â””â”€â”€ STATUS.md
```

**Purpose**: Temporary working directory for intermediate artifacts during task execution.

**Lifecycle**:
1. **Created**: Automatically when task starts
2. **Used**: Store brainstorms, drafts, incomplete analysis
3. **Cleaned**: After task completes, extract valuable insights or delete

---

## ğŸ”„ Incremental Work Principle

### The Problem: Context Overflow in Large Tasks

**Challenge**: Large tasks can easily exceed context window limits and lose continuity if interrupted.

**Example**:
```
âŒ Monolithic Approach:
Task: "Create 40-slide presentation based on all previous work"
Agent: Reads 9100 lines (all outputs)
       Writes 2000-line presentation in one go
       Updates memory at end

Problems:
- Context window overflow (11,000+ lines)
- Work lost if interrupted
- No progress tracking
- All-or-nothing execution
```

### The Solution: Incremental Steps with Memory Checkpoints

**Core Pattern**: Break large tasks into small incremental steps, updating memory after EACH step.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Step N: Do Work                         â”‚
â”‚ â€¢ Read memory (resume from checkpoint)  â”‚
â”‚ â€¢ Execute ONE incremental unit          â”‚
â”‚ â€¢ Keep context <2000 lines              â”‚
â”‚ â€¢ Create/update notes IMMEDIATELY       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
               â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Memory Checkpoint                        â”‚
â”‚ â€¢ Episodic note records progress        â”‚
â”‚ â€¢ Semantic notes capture insights       â”‚
â”‚ â€¢ Indexes updated                       â”‚
â”‚ â€¢ "Next Steps" documented               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
               â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Step N+1: Continue                      â”‚
â”‚ â€¢ Read memory (load next context)       â”‚
â”‚ â€¢ Next incremental unit                 â”‚
â”‚ ...                                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### When to Use Incremental Approach

**MANDATORY for tasks that**:
- âœ… Require reading >5000 lines of context
- âœ… Involve analyzing >10 files
- âœ… Produce outputs >1000 lines
- âœ… Have multiple distinct phases

**Optional for smaller tasks** (<5000 lines total context)

### Key Operating Rules

#### Context Budget Per Step
- **Single step context**: <2000 lines (hard limit)
- **Memory notes read**: <1000 lines
- **New code/docs read**: <1000 lines
- **Output produced**: <500 lines per step

#### Checkpoint Requirements
Every checkpoint MUST include in episodic note:
- âœ… **Completed Steps**: Mark current step as âœ… complete
- âœ… **Next Steps**: Define what comes next ([ ] pending items)
- âœ… **Context for Next Step**: What memory/files needed
- âœ… **Progress Tracking**: Timestamp, context used, outputs produced
- âœ… **Resumability Test**: "Can I resume from this if interrupted now?"

---

## Language Convention

- **Internal thinking**: {{THINK_LANGUAGE}} (for code analysis, technical reasoning)
- **External retrieval**: {{THINK_LANGUAGE}} (code, documentation, web search)
- **Final outputs**: {{USER_LANGUAGE}} (user-facing documentation, reports)
- **Memory notes**: Mixed ({{THINK_LANGUAGE}} for technical terms, {{USER_LANGUAGE}} for explanations)
- **Indexes**: {{THINK_LANGUAGE}} (for consistency and machine readability)

---

## Performance Metrics

### Expected System Performance

| Metric | Target | Notes |
|--------|--------|-------|
| **Context Reduction** | >70% | Via memory system and task-specific indexes |
| **Index Lookup Time** | <1 sec | Fast retrieval via JSON indexes |
| **Note Quality** | 100% | All notes pass quality checklist |
| **Memory Freshness** | <5 tasks old | Regular updates and hygiene cycles |

---

## Getting Started

### For New Sessions

```bash
# 1. Read this file (CLAUDE.md)
# 2. Read global configuration
Read /{{BASE_DIR}}/prompt/0.overview.md
Read /{{BASE_DIR}}/prompt/0.memory.md

# 3. Understand available knowledge
Read /{{BASE_DIR}}/memory/index/tags.json
Read /{{BASE_DIR}}/memory/index/topics.json

# 4. Check recent work
Read /{{BASE_DIR}}/memory/episodic/*.md (last 1-2 notes)

# 5. Wait for user request
# DO NOT read task prompts or outputs yet
```

### For Answering Questions

```bash
# 1. Query memory index
grep -i "<keyword>" /{{BASE_DIR}}/memory/index/tags.json

# 2. Read relevant semantic notes
Read /{{BASE_DIR}}/memory/semantic/<note>.md

# 3. Answer based on memory
# Only read codebase/outputs if memory insufficient
```

### For Executing Tasks

```bash
# 1. User says "Task N"
Read /{{BASE_DIR}}/prompt/<task-file>.md

# 2. Check for task-specific index
Read /{{BASE_DIR}}/memory/index/task-<N>-index.json (if exists)

# 3. Use index to read selectively
Read only sections specified in task index

# 4. Execute task using memory + selective reading

# 5. Update memory system
Create episodic note, update indexes
```

---

## Documentation Reference

### Core Documentation (Read First)

1. **`/{{BASE_DIR}}/CLAUDE.md`** (this file) - System architecture and usage
2. **`/{{BASE_DIR}}/prompt/0.overview.md`** - Global rules and conventions
3. **`/{{BASE_DIR}}/prompt/0.memory.md`** - Memory system policies
4. **`/{{BASE_DIR}}/memory/DESIGN.md`** - Memory system design

### Memory System Documentation

1. **`/{{BASE_DIR}}/memory/DESIGN.md`** - Complete memory system design
2. **`/{{BASE_DIR}}/memory/procedural/memory-system-operations.md`** - Operational procedures
3. **`/{{BASE_DIR}}/memory/procedural/memory-first-workflow.md`** - Mandatory workflow

### Quick Reference

- **Find knowledge**: `/{{BASE_DIR}}/memory/index/tags.json`, `topics.json`
- **Stable facts**: `/{{BASE_DIR}}/memory/semantic/*.md`
- **Task history**: `/{{BASE_DIR}}/memory/episodic/*.md`
- **Workflows**: `/{{BASE_DIR}}/memory/procedural/*.md`
- **Task optimization**: `/{{BASE_DIR}}/memory/index/task-<N>-index.json`

---

## Summary: The Memory-First Principle

### Core Philosophy

**âŒ Old Approach** (Context-Intensive):
```
Session Start â†’ Read all prompts â†’ Read all outputs â†’ Answer questions
Context Used: 10,000+ lines
```

**âœ… New Approach** (Memory-Driven):
```
Session Start â†’ Read indexes â†’ Query memory â†’ Read selectively â†’ Answer questions
Context Used: 500-1200 lines (80-95% reduction)
```

### Key Rules

1. **Memory First**: Always query memory indexes before reading prompts or outputs
2. **On-Demand Tasks**: Only read task prompts when user explicitly requests a task
3. **Selective Reading**: Use task-specific indexes to read only needed sections
4. **Update Memory**: After tasks, create episodic notes and update indexes
5. **Avoid Waste**: Never read files "just to see what's there"

---

## Ready to Start?

**Next Steps**:
1. âœ… You've read CLAUDE.md
2. ğŸ“– Read `/{{BASE_DIR}}/prompt/0.overview.md` for global rules
3. ğŸ“– Read `/{{BASE_DIR}}/prompt/0.memory.md` for memory policies
4. ğŸ“– Read `/{{BASE_DIR}}/memory/index/tags.json` and `topics.json`
5. ğŸ“– Read last 1-2 episodic notes in `/{{BASE_DIR}}/memory/episodic/`
6. ğŸ¯ Wait for user to request a specific task or ask a question

**Do NOT**:
- âŒ Read task prompts yet
- âŒ Read task outputs yet
- âŒ "Browse" the directory structure

**The memory system will tell you what exists. Use it.**

---

**Configuration Variables for This Template**:

- `{{PROJECT_NAME}}`: Name of the project
- `{{PROJECT_DESCRIPTION}}`: What the project does
- `{{BASE_DIR}}`: Base directory (usually "claude")
- `{{USER_LANGUAGE}}`: Language for outputs (e.g., "Chinese", "English")
- `{{THINK_LANGUAGE}}`: Language for thinking (usually "English")
- `{{LAST_UPDATED}}`: Last update date (YYYY-MM-DD)

**Version**: 1.0.0 (Template)
**Last Updated**: {{LAST_UPDATED}}
**System Status**: âœ… Production-Ready
